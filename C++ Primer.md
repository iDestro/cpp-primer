# C++ Primer 

记录学习C++的点点滴滴~~~

## 第1章 开始

### 1.1 编写一个简单的C++程序

### 1.2 初始输入输出

一个流就是一个字符序列。术语“流”(stream)想要表达的是，随着时间的推移，字符是顺序生成或消耗的。

系统通常将程序所运行的窗口与这些对象关联起来。因此，当我们读取`cin`，数据将从程序正在运行的窗口读入，当我们向`cout`、`cerr`和`clog`写入数据时，将会写到同一个窗口。

```c++
std::cout << "Enter two numbers:";
std::cout << std::endl;
```

上面双引号括着的是一个**字符串字面值常量(string literal)**。`endl`是一个**操纵符(manipulator)**的特殊值。写入`endl`的效果是结束当前行，并将与设备关联的**缓冲区(buffer)**中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。

> 程序员常常在调试时添加打印语句。这类语句应该保证“一直”刷新流。否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。

### 1.3 注释简介

使用`//`注释与使用注释界定符`/*...*/`，其中注释界定符不能嵌套。

### 1.4 控制流

#### 1.4.3 读取数数量不确定的输入数据

```c++
#include <iostream>
using namespace std;
int main() {
    int sum = 0, value = 0;
    // 读取数据直到遇到文件尾，计算所有读入的值的和
    while (cin >> value) {
        sum += value; // 等价于sum = sum + value
    }
    cout << "Sum is: " << sum << endl;
    return 0;
}
```

当我们使用一个`istream`对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到`文件结束符(end-of-file)`，或遇到无效的`istream`对象会使条件变为假。

**从键盘输入文件结束符**

当从键盘向程序输入数据时，对于如何指出文件结束，不同操作系统有不同的约定。在Windows系统中，输入文件结束符的方法是敲`Ctrl+Z`（按住`Ctrl`键的同时按`Z`键），然后按`Enter`或`Return`键。在UNIX系统中，包括Max OS X系统中，文件结束符输入是用`Ctrl+D`。

### 1.5 类简介

使用文件重定向

```bash
$ addItem <infile >outfile
```

### 1.6 书店程序

## 第2章 变量和基本类型

### 2.1 基本内置类型

#### 2.1.1 算术类型

通常`float`以1个字（32比特）来表示，`double`以2个字（64比特）来表示，`long double`以3或4个字（96或128比特）来表示。一般来说，类型`float`和`double`分别有7和16个有效位；类型`long double`则常常被用于有特殊浮点需求的硬件，它的具体实现不同，精度也各不相同。

**带符号类型和无符号类型**

类型`unsigned int`可以缩写为`unsigned`。与其它整型不同，字符型被分为了三种：`char`、`signed char`、`unsigned char`。类型`char`实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。C++标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该**平衡**。大多数现代计算机将实际的表示范围定为-128至127。

**如何选择类型**

执行浮点数运算选用`double`，这是因为`float`通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。`long double`提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗是不可忽视的。

#### 2.1.2 类型转换

当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。

当我们赋给带符号类型一个超出它表示范围的值时，结果是**未定义的（undefined）**。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。

> 建议：避免无法预知和依赖于实现环境的行为

**含有无符号类型的表达式**

当一个算数表达式中既有无符号数又有`int`值时，那个`int`值就会转换成无符号数。

下面是一个误用无符号数产生的死循环：

```c++
for (unsinged u = 10; u >= 0; u--)
    cout << u << endl;
```

> 切勿混用带符号类型和无符号类型

#### 2.1.3 字面量常量

默认情况下，十进制字面量是带符号数，八进制和十六进制字面量既可能是带符号的也可能是无符号的。十进制字面量的类型是`int`、`long`和`long long`中尺寸最小的那个（例如，三者当中最小的是`int`）,当然前提是这种类型要容纳下当前的值。

类型`short`没有对应的字面量。

十进制字面量不会是负数。

**字符和字符串字面量**

如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。

### 2.2 变量

#### 2.2.1 变量定义

C++新标准可以使用花括号来初始化变量。

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

当用于**内置类型**的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。

```c++
long double id = 3.1415926536;
int a{id}, b = {id};  // 错误：转换未执行，因为存在丢失信息的危险。
```

**默认初始化**

定义于任何函数体外的变量被初始化为0.

#### 2.2.2 变量声明和定义的关系

在函数体内部，如果试图初始化一个由`extern`关键字标记的变量，将引发错误。

> Note:变量能且只能定义一次，但是可以被多次声明。

#### 2.2.3 标识符

#### 2.2.4 名字的作用域

> 建议：当你第一次使用变量时再定义它

作用域能彼此包含，被包含（或者说被嵌套）的作用域称为**内层作用域**，包含着别的作用域的作用域称为**外层作用域**。允许在内层作用域中重新定义外层作用域已有的名字。

### 2.3 复合类型

### 2.4 const限定符

### 2.5 处理类型

### 2.6 自定义数据结构