# C++ Primer 

记录学习C++的点点滴滴~~~

## 第1章 开始

### 1.1 编写一个简单的C++程序

### 1.2 初始输入输出

一个流就是一个字符序列。术语“流”(stream)想要表达的是，随着时间的推移，字符是顺序生成或消耗的。

系统通常将程序所运行的窗口与这些对象关联起来。因此，当我们读取`cin`，数据将从程序正在运行的窗口读入，当我们向`cout`、`cerr`和`clog`写入数据时，将会写到同一个窗口。

```c++
std::cout << "Enter two numbers:";
std::cout << std::endl;
```

上面双引号括着的是一个**字符串字面值常量(string literal)**。`endl`是一个**操纵符(manipulator)**的特殊值。写入`endl`的效果是结束当前行，并将与设备关联的**缓冲区(buffer)**中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。

> 程序员常常在调试时添加打印语句。这类语句应该保证“一直”刷新流。否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。

### 1.3 注释简介

使用`//`注释与使用注释界定符`/*...*/`，其中注释界定符不能嵌套。

### 1.4 控制流

#### 1.4.3 读取数数量不确定的输入数据

```c++
#include <iostream>
using namespace std;
int main() {
    int sum = 0, value = 0;
    // 读取数据直到遇到文件尾，计算所有读入的值的和
    while (cin >> value) {
        sum += value; // 等价于sum = sum + value
    }
    cout << "Sum is: " << sum << endl;
    return 0;
}
```

当我们使用一个`istream`对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到`文件结束符(end-of-file)`，或遇到无效的`istream`对象会使条件变为假。

**从键盘输入文件结束符**

当从键盘向程序输入数据时，对于如何指出文件结束，不同操作系统有不同的约定。在Windows系统中，输入文件结束符的方法是敲`Ctrl+Z`（按住`Ctrl`键的同时按`Z`键），然后按`Enter`或`Return`键。在UNIX系统中，包括Max OS X系统中，文件结束符输入是用`Ctrl+D`。

### 1.5 类简介

使用文件重定向

```bash
$ addItem <infile >outfile
```

### 1.6 书店程序

## 第2章 变量和基本类型

### 2.1 基本内置类型

#### 2.1.1 算术类型

通常`float`以1个字（32比特）来表示，`double`以2个字（64比特）来表示，`long double`以3或4个字（96或128比特）来表示。一般来说，类型`float`和`double`分别有7和16个有效位；类型`long double`则常常被用于有特殊浮点需求的硬件，它的具体实现不同，精度也各不相同。

**带符号类型和无符号类型**

类型`unsigned int`可以缩写为`unsigned`。与其它整型不同，字符型被分为了三种：`char`、`signed char`、`unsigned char`。类型`char`实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。C++标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该**平衡**。大多数现代计算机将实际的表示范围定为-128至127。

**如何选择类型**

执行浮点数运算选用`double`，这是因为`float`通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。`long double`提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗是不可忽视的。

#### 2.1.2 类型转换

当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。

当我们赋给带符号类型一个超出它表示范围的值时，结果是**未定义的（undefined）**。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。

> 建议：避免无法预知和依赖于实现环境的行为

**含有无符号类型的表达式**

当一个算数表达式中既有无符号数又有`int`值时，那个`int`值就会转换成无符号数。

下面是一个误用无符号数产生的死循环：

```c++
for (unsinged u = 10; u >= 0; u--)
    cout << u << endl;
```

> 切勿混用带符号类型和无符号类型

#### 2.1.3 字面量常量

默认情况下，十进制字面量是带符号数，八进制和十六进制字面量既可能是带符号的也可能是无符号的。十进制字面量的类型是`int`、`long`和`long long`中尺寸最小的那个（例如，三者当中最小的是`int`）,当然前提是这种类型要容纳下当前的值。

类型`short`没有对应的字面量。

十进制字面量不会是负数。

**字符和字符串字面量**

如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。

### 2.2 变量

#### 2.2.1 变量定义

C++新标准可以使用花括号来初始化变量。

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

当用于**内置类型**的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。

```c++
long double id = 3.1415926536;
int a{id}, b = {id};  // 错误：转换未执行，因为存在丢失信息的危险。
```

**默认初始化**

定义于任何函数体外的变量被初始化为0.

#### 2.2.2 变量声明和定义的关系

在函数体内部，如果试图初始化一个由`extern`关键字标记的变量，将引发错误。

> Note:变量能且只能定义一次，但是可以被多次声明。

#### 2.2.3 标识符

#### 2.2.4 名字的作用域

> 建议：当你第一次使用变量时再定义它

作用域能彼此包含，被包含（或者说被嵌套）的作用域称为**内层作用域**，包含着别的作用域的作用域称为**外层作用域**。允许在内层作用域中重新定义外层作用域已有的名字。

### 2.3 复合类型

**复合类型**是指基于其他类型定义的类型。C++语言有几种复合类型，这里将介绍引用和指针。

#### 2.3.1 引用

定义引用时，程序把引用和它的初始值**绑定（bind）**在一起，而不是将初始值拷贝给引用。引用必须初始化。

> **引用并非对象**，相反的，他只是为一个已经存在的对象所起的另外一个名字。
>
> 引用的类型都要和与之绑定的对象严格匹配，有两种例外情况。
>
> 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。

```c++
int &refVal4 = 10; // 错误：引用类型的初始值必须是一个对象
double dval = 3.14;
int &refVal5 = dval; // 错误：此处引用类型的初始值必须是int型对象
```

#### 2.3.2 指针

**指针本身就是一个对象**，可以进行赋值和拷贝，生命周期中可以先后指向不同的对象。定义时无需赋初值，和其它内置类型一样，在块级作用域内未初始化将会得到一个不确定的值。

> 指针的类型都要和它所指向的对象严格匹配，有两种例外情况。

**指针值**

- 指向一个对象
- 指向紧邻对象所占空间的下一个位置
- 空指针，意味着指针没有指向任何对象
- 无效指针，也就是上述情况之外的其他值

试图拷贝或以其它方式访问无效指针的值都将引发错误。编译器并不负责检查此类型错误，这一点和试图使用未经初始化的变量是一样的。尽管第二种和第三种形式的指针是有效的，但是显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。

**利用指针访问对象**

> 解引用操作仅适用于那些确实指向了某个对象的**有效指针**。

**空指针**

空指针不指向任何对象，下面介绍几种生成空指针的方法：

```c++
int *p1 = nullptr; // 等价于int *p1 = 0;
int *p2 = 0; // 直接将p2初始化为字面常量0
// 需要首先#include <cstdlib>
int *p3 = NULL; // 等价于int *p3 = 0; NULL宏定义的值为0
```

`nullptr`是C++11新标准，它是一种特殊类型的字面量，它可以被转成（参见2.1.2节，第32面）任意其它的指针类型。

把`int`变量直接赋给指针是错误的操作，即使`int`变量的值恰好等于0也不行。

```c++
int zero = 0;
pi = zero; // 错误：不能把int变量直接赋给指针
```

> 建议：初始化所有指针

**其它指针的操作**

如果指针的值是0，条件取false

```c++
int ival = 1024;
int *pi = 0; // pi合法，是一个空指针
int *pi2 = &ival; // pi2是一个合法的指针，存放在ival的地址
if (pi) // pi的值是0，因此条件的值是false
    // ...
if (pi2) // pi2指向ival，因此它的值不是0，条件的值是true
    // ...
```

**void* 指针**

void*是一种特殊的指针类型，可用于存放在任意对象的地址。

#### 2.3.3 理解复合类型的声明

**定义多个变量**

*的位置要偏右

**指向指针的指针**

二级、三级...指针

**指向指针的引用**

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。

```c++
int i = 42;
int *p; //p是一个int型指针
int *&r = p; // r是一个对指针p的引用
r = &i; // r引用了一个指针，因此给r赋值&i就是令p指向i
*r = 0; // 解引用r得到i，也就是p指向的对象，将i的值改为0
```

> 面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。

### 2.4 const限定符

有时我们希望定义这样一种变量，它的值不被改变。因为`const`对象一般创建后其值就不能改变，所以`const`对象必须初始化。

```c++
const int i = get_size(); // 正确：运行时初始化
const int j = 42; // 正确：编译时初始化
const int k; // 错误：k是一个未经初始化的常量
```

**默认情况下，const对象仅在文件内有效**

解决办法是：对于`const`变量不管是声明还是定义都添加`extern`关键字，这样只需要定义一次就可以了：

```c++
// file_1.cc定义并初始化了一个常量，该常量能被其他文件访问
extern const int bufSize = fcn();
// file_1.h头文件
extern const int bufSize; // 与file_1.cc中定义的bufSize是同一个
```

> Note:如果想在多个文件之间共享`const`对象，必须在变量的定义之前添加`extern`关键字。

#### 2.4.1 const的引用

可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为**对常量的引用**。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：

```c++
const int ci = 1024;
const int &r1 = ci; // 正确：引用及其对应的对象都是常量
r1 = 42; // 错误：r1是对常量的引用
int &r2 = ci // 错误：试图让一个非常量引用指向一个常量对象
```

> 术语：常量引用是对const的引用

**初始化和对const的引用**

这里将展示引用的第一个例外，在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成（参见2.1.2节，第32页）引用类型即可。尤其，允许一个常量引用绑定非常量的对象，字面值，甚至是个一般表达式。

```c++
int i = 42;
const int &r1 = i; // 允许将const int&绑定到一个普通int对象上
const int &r2 = 42; // 正确：r1是一个常量引用
const int &r3 = r1 * 2; // 正确：r3是一个常量引用
int &r4 = r1 * 2; // 错误：r4是一个普通的非常量引用
```

**对const的引用可能引用一个并非const的对象**

如果引用的是一个非const的对象，则可以通过其它途径修改对象的值。

#### 2.4.2 指针和const

指向常量的指针不能改变指针所指向对象的值。和常量引用类似，并没有规定一定得指向常量，自然地，被指向对象的值可通过其它途径修改。

**const指针**

指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针（const pointer）必须初始化，而且一旦初始化，则它的值（地址）就不能改变。即不变的是指针本身的值而非指向的那个值：

```c++
int errNumb = 0;
int *const curErr = &errNumb; // curErr将一直指向errNumb
const double pi = 3.14159;
const double *const pip = &pi; // pip是一个指向常量对象的常量指针
```

#### 2.4.3 顶层const

指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词**顶层const**表示指针本身是个常量，而用名词**底层const**表示指针所指的对象是一个常量。对于一般对象（非指针对象），仅有**顶层const**的说法。而指针兼顾两种说法。

底层const的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换为常量，反之不行。

#### 2.4.4 constexpr和常量表达式

**常量表达式**是指不会改变并且在编译过程就能得到计算结果的表达式。

**constexpr变量**

C++新标准规定，允许将变量声明为**constexpr**类型以便由编译器来验证变量的值是否是一个常量表达式，允许将变量声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：

```c++
constexpr int mf = 20; // 20是个常量
constexpr int limit = mf+1; // mf+1是个常量
constexpr int sz = size(); // 只有当size是一个constexpr函数时，才是一条正确的声明语句。
```

constexpr函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。

> Best practices: 一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。

**字面值类型**

constexpr时用到的类型为“字面值类型”，如算术类型、引用和指针都属于字面值类型。自定义类、IO库、string类型则不属于字面值类型，不能定义为constexpr变量。指针定义为constexpr类型时，必须初始化为`nullptr`或`0`，或则存储与某个固定地址中的对象。因为一般来说，函数体的变量并不是存放在固定地址中的，所以constexpr指针不能指向这样的变量。相对地，对于任何函数体外的变量，constexpr指针可以指向。

**指针和constexpr**

在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。其中关键在于constexpr把它所定义的对象置为了顶层const。

### 2.5 处理类型

#### 2.5.1 类型别名

传统的方法是使用关键字`typedef`

```c++
typedef double wages; // wages是double的同义词
typedef wages base, *p; // base是double的同义词，p是double*的同义词
```

新标准规定了一种新的方法，使用**别名声明**来定义类型的别名：

```c++
using SI = Sales_item; // SI是Sales_item的同义词
```

**指针、常量和类型别名**

不太懂说了啥？？？

#### 2.5.2 auto类型说明符

C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。

**复合类型、常量和auto**

编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。

auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针。

```c++
const int ci = i, &cr = ci;
auto b = ci; // b是一个整数（ci的顶层const特性被忽略掉了）
auto c = cr; // c是一个整数（cr是ci的别名，ci本身是一个顶层const）
auto d = &i; // d是个整型指针
auto e = &ci; // e是一个指向整数常量的指针（对常量对象取地址是一种底层const）
```

如果希望推断出的auto类型是一个顶层const，需要明确指出：

```c++
const auto f = ci; // ci的推演类型是int，f是const int
```

还可以将引用的类型设为auto，此时原来的初始化规则仍然适用：

```c++
auto &g = ci; // g是一个整型常量引用，绑定到ci
auto &h = 42; // 错误：不能为非常量引用绑定字面值
const auto &j = 42; // 正确：可以为常量引用绑定字面值
```

设置一个类型为auto引用时

#### 2.5.3 decltype类型指示符

C++新标准引入了第二种类型说明符`decltype`，它的作用是选择并返回操作数的数据类型。

decltype处理顶层const和引用的方式与auto有些许不同。

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x的类型是const int
decltype(cj) y = x; // y的类型是const int&, y绑定到变量x
decltype(cj) z; // 错误：z是一个引用，必须初始化
```

因为cj是一个引用，decltype(cj)的结果就是引用类型，因此作为引用的z必须初始化。需要指出的是，引用从来都作为其所指对象的同义词出现，只有在decltype处是一个例外。

**decltype和引用**

如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。有些表达式将向decltype返回一个引用类型。一般来说当这种情况发生时，**意味着该表达式的结果对象能作为一条赋值语句的左值：**

```c++
int i = 42, *p = &i, &r = i;
decltype(r+0) b; // 正确：加法的结果是int，因此b是一个（未初始化的）int
decltype(*p) c; //  错误：c是int&，必须初始化
```

如果表达式的内容是**解引用操作**，则decltype将得到引用类型。

**有一种情况需要特别注意：**对于decltype所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果不加括号，返回的结果就是该变量的类型，如果加了一个或多个括号，编译器就会把它当成一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型：

```c++
// decltype的表达式如果是加上了括号的变量，结果将是引用
decltype((i)) d; // 错误：d是int&, 必须初始化
```

> 切记：decltype((var))（注意是双层括号）的结果永远是引用，而decltype(var)结果只有当var本身就是一个引用时才是引用。

### 2.6 自定义数据结构

#### 2.6.2 定义Sales_data类型

C++新标准规定，可以未数据成员提供一个类内初始值。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。

#### 2.6.3 编写自己的头文件

**预处理器概述**